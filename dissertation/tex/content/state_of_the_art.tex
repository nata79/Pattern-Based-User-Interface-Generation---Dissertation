\chapter{State of the art}
In this chapter is described the state art regarding model driven development of user interfaces. It will be presented several techniques to develop user interfaces using model driven principles. There is significant ongoing research in this field since the late 1980s. This chapter makes a short summary of that research. Some works will be examined in more depth for the sake of example. 

Model driven development defining characteristic is that software development's primary focus and products are models rather than computer programs. The major advantage of this is that we express models using concepts that are much less bound to the underlying implementation technology and are much closer to the problem domain relative to most popular programming languages \cite{The_Pragmatics_of_Model-Driven_Development}.

Models are easier to maintain than the code itself and, most importantly, they're platform independent. This means that the same model can be used to generate code that runs on a desktop environment, a web environment or even a mobile environment. This makes a very important feature for user interfaces because modern applications are becoming more and more ubiquitous and it's highly complex and time consuming to build a user interface for every supported platform.

There are different kinds of models and several techniques to model user interfaces. Some tools like Janus\cite{janus} only require a domain model to generate a concrete user interface while others like Trident\cite{trident1, trident2} and Adept\cite{adept1} also use a task model. All these approaches automate part of the development process. Other approaches like ITS\cite{ITS} require more work from the developers because it doesn't generate any model.

Some more recent work have been using different techniques to generate user interfaces. Gadget\cite{gadget} or Supple\cite{supple} have been using optimization techniques to generate better concrete user interfaces

Patterns are widely used in every field of engineering. One of the earlier definitions of patterns can be found on \cite{A_Pattern_Language_Towns_Buildings_Construction}. Almost twenty years later patterns were brought to software engineering by \cite{Design_Patterns}.

Patterns bring many advantages, not only they make the development of a product less time consuming and thus less expensive but can also guarantee a higher level of quality because patterns are solutions that have been tested and used in other projects. IdealXML\cite{IdealXml_An_Interaction_Design_Tool, idealxml2} is a tool that helps developers to take advantage of patterns while developing user interface models.

Although there have been a lot of academic work surrounding model driven development of user interfaces, this work is struggling to be adopted by the industry. There are some theories for what is missing, in \cite{molina} is said that better tool support is needed and in \cite{IdealXml_An_Interaction_Design_Tool} is stated that a common language for representing user interface models is the next step.

UML \cite{The_Unified_Modeling_Language_Reference_Manual} is the industry standard for software modelling but, unfortunately, is not fit to model user interfaces. Fortunately, the software engineering community has developed some new modelling languages in the past few years to overcome this problem. UMLi \cite{User_Interface_Modeling_in_UMLi} is an extension to UML that provides an alternative diagram notation for describing abstract interaction objects. ConcurTaskTrees (CTT) \cite{ConcurTaskTrees_A_Diagrammatic_Notation_for_Specifying_Task_Models} aims at task modelling by dividing the task model is built in three essential parts:
\begin{itemize}
\item First a hierarchical logical decomposition of the tasks represented by a tree-like structure;
\item Then an identification of the temporal relationships among tasks at the same level;
\item And finally an identification of the objects associated with each task and of the actions which allow them to communicate with each other.
\end{itemize} 

UsiXML is a user interface description language aimed at expressing user interfaces built with various modalities of interaction and independently of them. UsiXML is XML compliant to enable flexible exchange of information and powerful communication between models and tools used in user interface engineering \cite{UsiXML_USer_Interface_eXtensible_Markup_Language}. One of the great advantages of UsiXML is platform independence providing a multi-path development of user interfaces \cite{UsiXML_a_Language_Supporting_Multi-Path_Development_of_User_Interfaces}. UsiXML characteristics and features give it the potential to become a standard for modelling user interfaces like UML is for software architecture.

There is a lot of work regarding model driven development for user interfaces and the idea that models can simplify the development process is becoming more consensual. Section \ref{section:early_days} focus on projects from the beginnings of model driven development of user interfaces, namely Janus on section \ref{subsection:janus} and Its, section \ref{subsection:ITS}.

Section \ref{section:optimization_based_generation_of_interfaces} will describe optimization based techniques and the Gadget and Supple projects will be examined with more depth.

Section \ref{section:user_interface_patterns} refers to the usage of patterns in user interface design . This section also includes an analysis of IdealXML, a knowledge based tool for designing user interfaces.

Section \ref{section:specification_languages} is about specification languages. UMLi and UsiXML will be analysed in details in sections \ref{subsection:umli} and \ref{subsection:usixml} respectively.

\input{content/state_of_the_art/early_days}
\input{content/state_of_the_art/optimization_based_generation_of_interfaces}
\input{content/state_of_the_art/user_interface_patterns}
\input{content/state_of_the_art/specification_languages}

\section{Conclusion}

The first tools in this chapter were Janus\cite{janus} and Its\cite{ITS}. These tools represent the beginning of model driven development of user interfaces and at the same time two different approaches to this subject. Developers using Janus will decrease the development time of their applications. This seems to be the main goal of the project. Because it only needs one input, the domain model, it doesn't take a lot of effort to create a user interface. Of course this also means that the generated user interface won't have the same quality as one built by hand (depending on the abilities of the developer) and this is the most criticized aspect of Janus. On the other hand, Its can produce high quality user interfaces. But the amount of work necessary to build something is huge compared to Janus. Its also provides a way to divide work through the development team which is a very interesting feature because it facilitates the implementation of different development methodologies alongside this tool.

By analysing these two projects one can infer that model driven development can be used with two objectives in mind:
\begin{enumerate}
\item to build low-cost prototypes of an application rapidly;
\item to enhance the quality of the final product.
\end{enumerate}

Janus is clearly a tool that can be used to rapidly create a prototype of an in development application that can be used to communicate with customers or other stake holders. Its is aimed at building better applications with large teams.

In section \ref{section:optimization_based_generation_of_interfaces} were introduced a couple of projects that use numeric optimization to generate user interfaces. The first project was Gadget\cite{gadget}. This is a framework that abstracts the programmer from the optimization itself. The problem with this project is that it's not a complete solution. Developers still have to produce evaluations which can be a tricky subject because it's not trivial to determine what properties make a user interface  ``good''. The second project, Supple\cite{supple}, it's more mature and complete. The objective behind Supple is to generate user interfaces at run time that are optimal to people with special needs.

Although Gadget is meant to simplify numeric optimization of user interfaces in a way that it could be used by any developer it still looks very complex to use this system.

Supple is a more complete system. It receives three types of input models:
\begin{itemize}
\item one related to the domain;
\item other related to the user;
\item and other related to the platform it's supposed to run on.
\end{itemize}

This makes Supple easier for developers but doesn't give them much control of the final user interface. The great advantage of this system is his capability to dynamically adapt to the needs of every user.

Section \ref{section:user_interface_patterns} covered the use of user interface patterns in the process of modelling a user interface. In this section IdealXML\cite{IdealXml_An_Interaction_Design_Tool, idealxml2} was looked in detail. IdeaXML is a tool where designers can, using several graphical notations, specify domain models, task models, abstract presentation models and mapping models between them. IdealXML manipulates a pattern repository, where patterns are organized following a hierarchical structure. This enables the usage of patterns at design time.

Unfortunately, like in most projects in this field, IdealXML is an academic project and it's not ready to be adopted by the industry.

Section \ref{section:specification_languages} covered ``Specification Languages''. The reason why this topic was approached in this document is that probably the most important problem with model driven development of user interfaces is the lack of standard specification language like UML.

The first language in this section is UMLi\cite{User_Interface_Modeling_in_UMLi}. This language is an extension to UML that supports every major step of model driven development of user interfaces. It only lacks support for the \textit{concrete user interface model}.

Lastly, UsiXML\cite{UsiXML_a_Language_Supporting_Multi-Path_Development_of_User_Interfaces}. UsiXML is a User Interface Description Language based on the Cameleon reference framework\cite{Calvary}. UsiXML supports every step in the Cameleon framework, including the concrete one, unlike UMLi.

UsiXML also ships with an engineering method and meta-method. Which allows development teams to easily adopt this technology and adapt the methodology according to their needs.

Not just because of all the advantages it provides but also because of it's vast community, UsiXML seems to have the potential to become the standard specification language for user interface specification.