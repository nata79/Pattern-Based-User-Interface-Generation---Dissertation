\subsection{Supple}
\label{subsection:Supple}

Most of today's software interfaces are designed with the assumption that they are going to be used by an able-bodied person, who is using a typical set of input and output devices, who has typical perceptual and cognitive abilities, and who is sitting in a stable, warm environment. Any deviation from this pattern requires a new design. In \cite{supple} is argued that automatic personalized generation of interfaces is a feasible and scalable solution for this challenge. Supple can automatically generate interfaces adapted to a persons devices, tasks, preferences and abilities at run-time. It is not intended to replace user interface designers, instead it offers an alternative user interface for those people whose devices, tasks, preferences and abilities are not sufficiently addressed by the original designs.

Support for users with special needs is often forgotten by interface designers. When this problem is addressed there are three popular patters that are usually followed, manual redesign of the interface, limited customization support, or by supplying an external assistive technology. The first approach is clearly not scalable, new devices constantly enter the market, and people's abilities or preferences both differ greatly and often cannot be anticipated in advance. Second, today's customization approaches typically only support changes to the organization of tool bars and menus and cosmetic changes to other parts of the interface. Furthermore, even when given the opportunity, most people do not customize their applications. Finally, assistive technologies, while they often enable computer access for people who would otherwise not have it, also have limitations. They're impractical for users with temporal impairments, they do not adapt to people whose abilities change over time and they're often abandoned by people who need them because of factors like cost, complexity, configuration, and the need for ongoing maintenance.

In contrast with this approach, Supple generates personalized interfaces to suit the particular contexts of individual users. In order to be able to generate these personalized interfaces, Supple makes three important contributions:
\begin{itemize}
\item Defines an interface generation as a discrete constrained optimization problem and solve it with a branch-and-bound algorithm using constraint propagation. This general approach allows the Supple system to automatically generate ``optimal'' user interfaces given a declarative description of an interface, device characteristics, available widgets, and a user and device specific cost function.

\item Two types of cost functions were developed to guide the optimization process. The first is factored in a manner that enables preference-based personalization as well as fast computation, allowing Supple to generate user interfaces in under 1 second in most cases. The second explicitly models a person's ability to control the pointer, allowing Supple to generate user interfaces adapted to unusual interaction techniques or abilities, such as an input jittery eye tracker or a user's limited range of motion due to a motor impairment.

\item Supple also supports two approaches for dynamic personalization of generated interfaces: an automatic system driven adaptation to the current task, and a user driven customization.
\end{itemize}

Like other automatic user interface generation systems, Supple relies on an interface specification ($I$). Additionally, Supple also uses an explicit device model ($D$) to describe the capabilities and limitations of the platform for which the interface is to be generated. Finally, in order to reflect individual differences among usage patterns, Supple additionally includes a usage model, represented in terms of user traces ($T$).

Supple adopts a functional representation of user interfaces that is, one that says what functionality the interface should expose to the user instead of how to present those features. Like a number of previous systems, Supple represents basic functionality in terms of types of data that need to be exchanged between the application and the user. Semantic groupings of basic elements are expressed through container types which also serve as reusable abstractions. Supple chooses not to adopt a task-oriented approach for two reasons. First, because task-oriented descriptions are typically first compiled into a data-oriented functional description. Second, task-oriented languages are particularly useful for capturing task-oriented processes such as store checkout or making a hotel reservation. Most direct manipulation systems, however, support a broad range of possible tasks and make simultaneously available numerous reversible actions. Such interfaces would not benefit significantly from a task-oriented representation.

Formally an interface is defined to be $I \equiv \langle S_{f}, C_{I} \rangle $, where $S_{f}$ is a tree of interface elements, and $C_{I}$ is a set of interface constraints specified either by the designer at design time, or by the user at run time through Supple's customization mechanism. The interface elements included in the functional specification correspond to units of information that need to be conveyed via the interface between the user and the controlled application. The interface constraints can, in principle, constrain any aspect of interface presentation. In practice, it relies on the following three classes of constraints:
\begin{itemize}
\item \textbf{equality constraints}, which allow multiple instances of the same type to be rendered identically;

\item \textbf{constraints limiting the set of presentation options for an element}, which allow the user to customize the interface and choose from a set of available widgets to represent an element;

\item \textbf{interdependence constraints}, for example, not letting a check-box to be rendered alone inside of a tab pane.
\end{itemize}

The elements in the functional specification are defined in terms of their types. There are several classes of types:
\begin{itemize}
\item \textbf{Primitive types} include the common basic data types such as integers, floats, strings and booleans.

\item \textbf{Container types}, formally represented as $\lbrace \tau_{1}, \tau_{2}, â€¦, \tau_{n} \rbrace$, are used to create groups of simpler elements, $\tau_{i}$.

\item \textbf{Constrained types}, $ \langle \tau, C_{\tau} \rangle $, denotes a constrained type, where $\tau$ is any primitive or container type and $C_{\tau}$ is a set of constraints over the values of this type. The constraints can be of any type, but typically they are expressed as an enumeration of allowed values or as a range.

\item \textbf{Vectors elements}  $ ( \langle \tau, C_{\tau} \rangle ) $ denote an ordered sequence of zero or more values of type $\tau$ and are used to support multiple selection. Like in the constrained types, the constraints $C_{\tau}$ define the set of values of type $\tau$ that can be selected.

\item \textbf{Actions} are denoted with a functional type signature, $\tau_{1} \vdash \tau_{2}$, where $\tau_{1}$ stands for the type of the object containing parameters of the action and $\tau_{2}$ describes the return type, that is, the interface component that is to be displayed after the typical execution of the action. Unlike the other types which are used to represent an application's state, the action type is used to invoke application's methods.
\end{itemize}

A display-based device, in Supple, is modelled as a tuple, $D \equiv \langle W, C_{D} \rangle $, where $W$ is the set of available user interface widgets on that device and $C_{D}$ denotes a set of device-specific constraints. Widgets are objects that turn elements from the functional specification into components of a rendered interface. Like the interface constraints, the device-specific constraints in $C_{D}$ are simply functions that map a full or partial set of element-widget assignments to either $true$ or $false$.

Most people use only a small subset of functions available in any application, and different users use different subsets. To adapt to a person's tasks and long-term usage patterns, the user interface should be rendered such that important functionalism is easy to manipulate and to navigate to. Instead of relying on explicit annotations by the designer or the user, Supple relies on usage traces, which can correspond either to actual or anticipated usage. Usage traces provide not just interaction frequency for primitive widgets, but also frequencies of transitions among different interface elements. In the context of the optimization framework, traces offer the possibility of computing \textit{expected} cost with respect to anticipated use.

A usage trace $T$, is a set of \textit{trails} where the term trail refers to ``coherent'' sequences of elements manipulated by the user. Supple assumes that a trail ends when the interface is closed or otherwise reset. A trail $T$ is a sequence of events $u_{i}$, each of which is a tuple $ \langle e_{i}, V_{old_{i}}, V_{new_{i}} \rangle $. Here $e_{i}$ is the interface element manipulated and $V_{old_{i}}$ and $V_{new_{i}}$ refer to the old and new values this element assumed.

The goal of all these specifications is to render each interface element with a concrete widget. Thus a \textit{legal} rendering of a functional specification $S_{f}$ is defined to be a mapping $R: S_{f} \vdash W$ which satisfies the interface and device constraints in $C_{I}$ and $C_{D}$. Of course there are many \textit{legal} renderings. Therefore, in order to find the best one, Supple relies on a cost function $\$: R \vdash \Re \geq 0$, which provides quantitative metric of the user interface quality.

Supple is an optimization-based tool to generate user interfaces. Unlike GADGET it is not a simple framework to be used by programmers, it implements all the optimization related logic. Developers are only obliged to supply the specification. Unlike most of the recent tools in this field, Supple only requires the abstract user interface model and a set of constraints, it doesn't use tasks. The main advantage regarding other solutions is that constraint set is dynamic and depends both on the user and the device. This allows Supple to generate good user interfaces to every user even if the designer doesn't have much information about the users preferences.