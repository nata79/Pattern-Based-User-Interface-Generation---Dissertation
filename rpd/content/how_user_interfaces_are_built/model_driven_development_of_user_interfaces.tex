\subsection{Model driven development of user interfaces}
Model driven development defining characteristic is that software development's primary focus and products are models rather than computer programs. The major advantage of this is that we express models using concepts that are much less bound to the underlying implementation technology and are much closer to the problem domain relative to most popular programming languages \cite{The_Pragmatics_of_Model-Driven_Development}.

Models are easier to maintain than the code itself and, most important, they're platform independent. This means that the same model can be used to generate code that runs on a desktop environment, a web environment or even a mobile environment. This makes a lot of sense for user interfaces because modern applications are becoming more and more ubiquitous and it's highly complex and time consuming to build a GUI for every supported platform.

UML \cite{The_Unified_Modeling_Language_Reference_Manual} is the industry standard for software modelling but, unfortunately, is not fit to model user interfaces. With this in mind, the software engineering community has developed some new modelling languages in the past few years to overcome this problem. The most relevant are probably UMLi \cite{User_Interface_Modeling_in_UMLi}, an extension to UML and ConcurTaskTrees (CTT) \cite{ConcurTaskTrees_A_Diagrammatic_Notation_for_Specifying_Task_Models} which aims task modelling. UMLi provides an alternative diagram notation for describing abstract interaction objects. Figure \ref{content/how_user_interfaces_are_built/umli_login.png} shows our login window example modelled using UMLi.
\image{6cm}{content/how_user_interfaces_are_built/umli_login.png}{Login window modelled in UMLi}

With this notation you can specify inputs, outputs and actions in a way that classic UML notation doesn’t support. Tasks can also be specified in UMLi, but without any extension to UML. Tasks can be modeled using Use Cases and Activity Diagrams which are part of the UML specification.

In figure \ref{content/how_user_interfaces_are_built/umli_login.png}, the upper container as four entities, \textit{username} and \textit{password} represent input controls while \textit{UsernameParam} and \textit{PasswordParam} are bindings to where the content of inputs will be stored. On the lower container are represented the actions of the window.

Task modelling has become very popular for modelling interactive systems and it's, probably, the most important method right now. A task consists how a user can reach a goal in a specific context. CTT is the most popular language for task modelling. With CTT the task model is built in three phases:
\begin{itemize}
\item First a hierarchical logical decomposition of the tasks represented by a tree-like structure;
\item Then an identification of the temporal relationships among tasks at the same level;
\item And finally an identification of the objects associated with each task and of the actions which allow them to communicate with each other.
\end{itemize} 
\image{8cm}{content/how_user_interfaces_are_built/ctte_login.png}{Login task modelled in CTT}

Figure \ref{content/how_user_interfaces_are_built/ctte_login.png} shows the login task modelled in CTT. The tool used to create this model was CTTE \cite{ConcurTaskTrees_Environment} which is one of the most popular tools for the CTT language. This tool supports the creation and animation of models but doesn’t offer any feature to perform any transformation to a more specific format.

Another well known tool for CTT is \textit{IdealXML} \cite{IdealXml_An_Interaction_Design_Tool}. This tool can also be used to model tasks using CTT but it also has the capability to transform the models into more specific ones, namely, user interface specifications in \textit{UsiXML}.

In conclusion, there is a lot of work regarding model driven development for user interfaces and the idea that models can simplify the development process is becoming more consensual. The biggest problem with this methodology is the tool support that still isn't mature enough to be adopted by the industry. Being a method where the product of engineer's work is platform independent and both easily maintainable and reusable, model driven development will surely play an important role on the future of software development and more specifically on the development of user interfaces.

The tool proposed by this project fits in the model driven paradigm because it takes two inputs, the pattern specification, which is a model and the existing source code which is a concretion of other model and thus can also be viewed as a model. The output is a transformation of the first model based on information derived from the second one.